<!DOCTYPE html><html><title>kimjbstar blog</title><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,user-scalable=0"/><meta name="next-head-count" content="3"/><link rel="icon" href="/favicon.ico"/><link rel="preload" href="/me/_next/static/media/44c3f6d12248be7f-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/me/_next/static/css/6838b124ff7958ea.css" as="style"/><link rel="stylesheet" href="/me/_next/static/css/6838b124ff7958ea.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/me/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/me/_next/static/chunks/webpack-da34a509dec67879.js" defer=""></script><script src="/me/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/me/_next/static/chunks/main-e741c97d4b299d3b.js" defer=""></script><script src="/me/_next/static/chunks/pages/_app-8535781b1bd0808d.js" defer=""></script><script src="/me/_next/static/chunks/a486667b-8f2171b1f26cbdcb.js" defer=""></script><script src="/me/_next/static/chunks/664-7e38c18dd603f57f.js" defer=""></script><script src="/me/_next/static/chunks/345-14001e255a9bfd38.js" defer=""></script><script src="/me/_next/static/chunks/pages/blog/%5Bid%5D-b2c0b9f35c8b102a.js" defer=""></script><script src="/me/_next/static/jqeohQA3pGbITjzOP0kuA/_buildManifest.js" defer=""></script><script src="/me/_next/static/jqeohQA3pGbITjzOP0kuA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_4ba71e"><nav class="text-s flex justify-center border-b-2 border-gray-100"><div class="flex justify-around max-w-[1200px] w-full"><div class="p-6"><a href="/me/about">About</a></div><div class="p-6"><a href="/me/blog">Blog</a></div><div class="p-6"><a href="/me/other">Other</a></div></div></nav><div class="md:p-16 p-4"><section class="flex flex-col items-center mt-20"><div class="text-6xl mb-10 font-bold text-gray-800">serverless를 활용하여 간단한 크롤링 서비스 AWS Lambda에 배포</div><div class="text-4xl mb-10 text-gray-700"></div><div class="self-end">2020년 06월 16일</div><div class="p-4"><div class="markdown-body"><h1>서론</h1>
<p>just1s 토이 프로젝트를 진행하면서 한가지 불편한 기능이 있었는데, youtube 링크를 넣고 미리보기 까지는 가능하나, 아티스트와 제목은 수동으로 입력해야 한다는 점이었습니다. 물론 수동으로 입력하는 게 기본적으로는 맞지만 youtube 페이지 하단을 보면 일부는 영상에 사용된 음악 정보가 나옵니다. 이 정보를 파싱하여 자동으로 입력할 수 있다면 deck 추가 시 생산성 및 편의성을 높일 수 있지 않을까 생각했습니다.</p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt01.png" alt=""/></p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt02.png" alt=""/></p>
<h1>puppeteer를 활용한 크롤링</h1>
<p>puppeteer는 node.js 진영에서 크롤링에 가장 많이 사용하는 라이브러리로써, chrome 혹은 chromium 엔진을 headless로 동작시켜 크롤링에 사용합니다.</p>
<p>사실 puppeteer 같은 경우 레이블그룹 재직 시절에도 일부 사용했었습니다. 카톡 등 메신저에서 처럼 링크 공유 시 썸네일, 타이틀 표시 기능, 각종 패션 쇼핑몰 크롤링 등 자잘하게 사용했었습니다.</p>
<p>youtube 페이지 같은 경우 script 쪽을 찾아보면 window[&quot;ytInitialData&quot;]에 json object 가 선언되어 있는데 이 정보 찾아 내려가면 음악 정보가 있습니다.</p>
<p>key로 youtube의 videoId를 받아 해당 json을 파싱하여 결과를 반환하는 매우 간단한 서버를 만들었습니다. 아래 링크를 참고하여 작업했습니다.</p>
<p><a href="https://velog.io/@jeffyoun/AWS-Lambda%EC%97%90%EC%84%9C-Puppeteer%EB%A1%9C-%ED%81%AC%EB%A1%A4%EB%A7%81-%ED%95%98%EA%B8%B0">AWS Lambda에서 Puppeteer로 크롤링 하기</a></p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt03.png" alt=""/></p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt04.png" alt=""/></p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt05.png" alt=""/></p>
<h1>lambda, serverless</h1>
<p>이를 이제 배포하여 사용할수 있도록 해야 하는데 ec2에 생으로 올리기에는 이미 클러스터로 사용하고 있고, 또 컨테이너화 시켜 ECS 클러스터에 배포하기도 애매해서, lambda에 배포해 보기로 결정했습니다. 또한 직접 배포할 수도 있지만 serverless를 통해 배포를 어느정도 자동화 시켜보도록 하기로 했습니다.</p>
<p>여기서 serverless에 대해 조금 더 언급하자면, serverless 자체가 개념적인 단어이기도 하면서 동명인 serverless 프레임워크가 그 중 유명합니다. serverless의 개념적인 뜻으로는 서버가 없다는 뜻이 아니라 서버 구축 관리에 대한 고민이 없다 라고 생각하면 편할 것 같습니다.</p>
<p><a href="https://www.serverless.com/">The Serverless Application Framework | Serverless.com</a></p>
<p>serverless 프레임워크는 AWS 뿐만 아니라 GCP, Azure 등 다양한 플랫폼을 지원합니다.</p>
<p>간단한 사용법으로는</p>
<ol>
<li>npm i -g serverless 로 serverless를 설치</li>
<li>serverless config credentials --provider aws --key &lt;AWS IAM 키&gt; --secret &lt;AWS IAM 시크릿&gt; 으로 aws credential 정보를 cli 상에서 사용할 수 있도록 처리</li>
<li>sls create -t aws-nodejs -p &lt;프로젝트명&gt; 로 프로젝트를 생성. ( sls = serverless )</li>
<li>기능을 function으로 정의 후 serverless.yml을 정의. start를 call 하면 src/index.handler function이 실행</li>
<li>sls deploy로 배포</li>
</ol>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt06.png" alt=""/></p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt07.png" alt=""/></p>
<p>여기까지 따라하면 일반적 상황에서는 문제 없이 배포가 가능합니다. 여담으로 저는 IAM permission 이슈로 바로 배포를 할 수 없었는데 당시에 실수로 aws key를 넣은 테스트 코드를 커밋한 적이 있어서 aws에서 이를 차단하는 permission을 추가했는데 이를 인지 못해서 삽질을 조금 하긴 했습니다. permission은 당연히 &quot;allow&quot;만 있는 줄 알고 &quot;deny&quot;가 있는 줄 몰라 일어난 해프닝이었습니다.</p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt08.png" alt=""/></p>
<p>DO_NOT_REMOVE로 끝나는 permission이 AWS에서 자동으로 추가한 permission입니다. 여기 iam:createRole등을 막는 정책이 포함되어 있었습니다.</p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt09.png" alt=""/></p>
<p>이 이슈를 발견하게 된 계기는 policy simulator라는 페이지를 우연히 발견하고, 여기에 정책을 선택에 이것이 허용되었는지, 제한되어 있다면 어떤 정책이 막고 있는 지 등을 확인해 볼수 있는 기능이 있어 발견하게 되었습니다.</p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt10.png" alt=""/></p>
<p>어쨌든 원래 주제로 돌아와, 관련 이슈를 해결하고 정상적으로 배포한 모습입니다. serverless가 serverless.yml 파일 기반으로 AWS CloudFormation yml을 생성하고, 그 cloudformation을 통해 S3 bucket에 배포, Lambda에 연결, API Gateway 연결 등을 하여 실행시키는 모습입니다. 좀 더 light-weight하게 구성하려면 serverless가 cloudformation을 생성하지 않고 lambda function에 바로 배포하게 할 수도 있지만 우선은 권장되는 기본 옵션으로 진행했습니다. production에 실제 적용하기 위해서는 serverless보다도 cloudformation, API Gateway, Lambda에 대한 추가적인 공부가 필요할 것으로 보입니다.</p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt11.png" alt=""/></p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt12.png" alt=""/></p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt13.png" alt=""/></p>
<h1>결론 및 또 다른 고민</h1>
<p>just1s 프로젝트의 기존 back-end, front-end는 docker container 기반으로 ECS cluster를 통해 배포했고, 지금 수행한 serverless 기반의 lambda로 배포했습니다.</p>
<p>사실 기존의 방식으로 구축한 이유는 docker, container, orchestration을 어느 정도 공부해보고 싶기도 했고, 근본적으론 작성한 코드가 어디서든 같은 인프라 위에서 동작을 하게끔 하고 싶은 의도에서 비롯된 것이었습니다. ( It Works on My Machine 방지 )</p>
<p>직접 해보니 이렇게 serverless 기반으로 배포해도 내가 의도했던 것과 비슷한 그림이 나옵니다. 결국 Infrastructure as Code 니까.</p>
<ul>
<li>명세
<ul>
<li>dockerfile, docker-compose.yaml, AWS ECS task definition, AWS ECS service</li>
<li>serverless.yaml, AWS Cloudformation</li>
</ul>
</li>
<li>배포
<ul>
<li>AWS ECS cluter + Docker container</li>
<li>AWS lambda</li>
</ul>
</li>
</ul>
<p>이렇게 되어 또 고민이 생겼는데 언제 serverless로 배포하고, container로 배포할지에 대한 고민이었습니다. 이에 대한 이슈는 검색해보면 여러 글이 많습니다.</p>
<p><a href="https://www.cloudflare.com/learning/serverless/serverless-vs-containers/"></a></p>
<p>공통적으로 언급되는 점은 규모가 작고 접속이 일정하지 않고 scale 걱정을 하지 않아도 되는 간단한 서비스는 serverless로, 그 반대의 경우 및 서비스가 돌아가는 enviroment를 더 제어하고 싶을 떼에는 container에 배포하는 것을 권장하는 듯 합니다.</p>
<p>그러한 점을 기반으로 just1s 프로젝트의 배포 구조를 보면 웹 서버 같은 경우는 container 기반, 파서와 같은 서비스는 serverless로 배포했으니 나름 worst practice는 피한 구조라고 할 수 있지 않을까 생각합니다.</p></div></div></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"blog":{"id":"3a10ad75-af53-4d54-a8ba-7239d8ff3b8a","title":"serverless를 활용하여 간단한 크롤링 서비스 AWS Lambda에 배포","content":"# 서론\n\njust1s 토이 프로젝트를 진행하면서 한가지 불편한 기능이 있었는데, youtube 링크를 넣고 미리보기 까지는 가능하나, 아티스트와 제목은 수동으로 입력해야 한다는 점이었습니다. 물론 수동으로 입력하는 게 기본적으로는 맞지만 youtube 페이지 하단을 보면 일부는 영상에 사용된 음악 정보가 나옵니다. 이 정보를 파싱하여 자동으로 입력할 수 있다면 deck 추가 시 생산성 및 편의성을 높일 수 있지 않을까 생각했습니다.\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt01.png)\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt02.png)\n\n# puppeteer를 활용한 크롤링\n\npuppeteer는 node.js 진영에서 크롤링에 가장 많이 사용하는 라이브러리로써, chrome 혹은 chromium 엔진을 headless로 동작시켜 크롤링에 사용합니다.\n\n사실 puppeteer 같은 경우 레이블그룹 재직 시절에도 일부 사용했었습니다. 카톡 등 메신저에서 처럼 링크 공유 시 썸네일, 타이틀 표시 기능, 각종 패션 쇼핑몰 크롤링 등 자잘하게 사용했었습니다.\n\nyoutube 페이지 같은 경우 script 쪽을 찾아보면 window[\"ytInitialData\"]에 json object 가 선언되어 있는데 이 정보 찾아 내려가면 음악 정보가 있습니다.\n\nkey로 youtube의 videoId를 받아 해당 json을 파싱하여 결과를 반환하는 매우 간단한 서버를 만들었습니다. 아래 링크를 참고하여 작업했습니다.\n\n[AWS Lambda에서 Puppeteer로 크롤링 하기](https://velog.io/@jeffyoun/AWS-Lambda%EC%97%90%EC%84%9C-Puppeteer%EB%A1%9C-%ED%81%AC%EB%A1%A4%EB%A7%81-%ED%95%98%EA%B8%B0)\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt03.png)\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt04.png)\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt05.png)\n\n# lambda, serverless\n\n이를 이제 배포하여 사용할수 있도록 해야 하는데 ec2에 생으로 올리기에는 이미 클러스터로 사용하고 있고, 또 컨테이너화 시켜 ECS 클러스터에 배포하기도 애매해서, lambda에 배포해 보기로 결정했습니다. 또한 직접 배포할 수도 있지만 serverless를 통해 배포를 어느정도 자동화 시켜보도록 하기로 했습니다.\n\n여기서 serverless에 대해 조금 더 언급하자면, serverless 자체가 개념적인 단어이기도 하면서 동명인 serverless 프레임워크가 그 중 유명합니다. serverless의 개념적인 뜻으로는 서버가 없다는 뜻이 아니라 서버 구축 관리에 대한 고민이 없다 라고 생각하면 편할 것 같습니다.\n\n[The Serverless Application Framework | Serverless.com](https://www.serverless.com/)\n\nserverless 프레임워크는 AWS 뿐만 아니라 GCP, Azure 등 다양한 플랫폼을 지원합니다.\n\n간단한 사용법으로는\n\n1. npm i -g serverless 로 serverless를 설치\n2. serverless config credentials --provider aws --key \u003cAWS IAM 키\u003e --secret \u003cAWS IAM 시크릿\u003e 으로 aws credential 정보를 cli 상에서 사용할 수 있도록 처리\n3. sls create -t aws-nodejs -p \u003c프로젝트명\u003e 로 프로젝트를 생성. ( sls = serverless )\n4. 기능을 function으로 정의 후 serverless.yml을 정의. start를 call 하면 src/index.handler function이 실행\n5. sls deploy로 배포\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt06.png)\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt07.png)\n\n여기까지 따라하면 일반적 상황에서는 문제 없이 배포가 가능합니다. 여담으로 저는 IAM permission 이슈로 바로 배포를 할 수 없었는데 당시에 실수로 aws key를 넣은 테스트 코드를 커밋한 적이 있어서 aws에서 이를 차단하는 permission을 추가했는데 이를 인지 못해서 삽질을 조금 하긴 했습니다. permission은 당연히 \"allow\"만 있는 줄 알고 \"deny\"가 있는 줄 몰라 일어난 해프닝이었습니다.\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt08.png)\n\nDO_NOT_REMOVE로 끝나는 permission이 AWS에서 자동으로 추가한 permission입니다. 여기 iam:createRole등을 막는 정책이 포함되어 있었습니다.\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt09.png)\n\n이 이슈를 발견하게 된 계기는 policy simulator라는 페이지를 우연히 발견하고, 여기에 정책을 선택에 이것이 허용되었는지, 제한되어 있다면 어떤 정책이 막고 있는 지 등을 확인해 볼수 있는 기능이 있어 발견하게 되었습니다.\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt10.png)\n\n어쨌든 원래 주제로 돌아와, 관련 이슈를 해결하고 정상적으로 배포한 모습입니다. serverless가 serverless.yml 파일 기반으로 AWS CloudFormation yml을 생성하고, 그 cloudformation을 통해 S3 bucket에 배포, Lambda에 연결, API Gateway 연결 등을 하여 실행시키는 모습입니다. 좀 더 light-weight하게 구성하려면 serverless가 cloudformation을 생성하지 않고 lambda function에 바로 배포하게 할 수도 있지만 우선은 권장되는 기본 옵션으로 진행했습니다. production에 실제 적용하기 위해서는 serverless보다도 cloudformation, API Gateway, Lambda에 대한 추가적인 공부가 필요할 것으로 보입니다.\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt11.png)\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt12.png)\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/yt13.png)\n\n# 결론 및 또 다른 고민\n\njust1s 프로젝트의 기존 back-end, front-end는 docker container 기반으로 ECS cluster를 통해 배포했고, 지금 수행한 serverless 기반의 lambda로 배포했습니다.\n\n사실 기존의 방식으로 구축한 이유는 docker, container, orchestration을 어느 정도 공부해보고 싶기도 했고, 근본적으론 작성한 코드가 어디서든 같은 인프라 위에서 동작을 하게끔 하고 싶은 의도에서 비롯된 것이었습니다. ( It Works on My Machine 방지 )\n\n직접 해보니 이렇게 serverless 기반으로 배포해도 내가 의도했던 것과 비슷한 그림이 나옵니다. 결국 Infrastructure as Code 니까.\n\n- 명세\n    - dockerfile, docker-compose.yaml, AWS ECS task definition, AWS ECS service\n    - serverless.yaml, AWS Cloudformation\n- 배포\n    - AWS ECS cluter + Docker container\n    - AWS lambda\n\n이렇게 되어 또 고민이 생겼는데 언제 serverless로 배포하고, container로 배포할지에 대한 고민이었습니다. 이에 대한 이슈는 검색해보면 여러 글이 많습니다.\n\n[](https://www.cloudflare.com/learning/serverless/serverless-vs-containers/)\n\n공통적으로 언급되는 점은 규모가 작고 접속이 일정하지 않고 scale 걱정을 하지 않아도 되는 간단한 서비스는 serverless로, 그 반대의 경우 및 서비스가 돌아가는 enviroment를 더 제어하고 싶을 떼에는 container에 배포하는 것을 권장하는 듯 합니다.\n\n그러한 점을 기반으로 just1s 프로젝트의 배포 구조를 보면 웹 서버 같은 경우는 container 기반, 파서와 같은 서비스는 serverless로 배포했으니 나름 worst practice는 피한 구조라고 할 수 있지 않을까 생각합니다.","created_at":"2020-06-16T08:41:18+00:00","subtitle":null,"is_show":true}},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"3a10ad75-af53-4d54-a8ba-7239d8ff3b8a"},"buildId":"jqeohQA3pGbITjzOP0kuA","assetPrefix":"/me","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>