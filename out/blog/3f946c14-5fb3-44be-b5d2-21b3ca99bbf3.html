<!DOCTYPE html><html><title>kimjbstar blog</title><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,user-scalable=0"/><meta name="next-head-count" content="3"/><link rel="icon" href="/favicon.ico"/><link rel="preload" href="/me/_next/static/media/44c3f6d12248be7f-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/me/_next/static/css/6838b124ff7958ea.css" as="style"/><link rel="stylesheet" href="/me/_next/static/css/6838b124ff7958ea.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/me/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/me/_next/static/chunks/webpack-da34a509dec67879.js" defer=""></script><script src="/me/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/me/_next/static/chunks/main-e741c97d4b299d3b.js" defer=""></script><script src="/me/_next/static/chunks/pages/_app-f3d8629c3f61a584.js" defer=""></script><script src="/me/_next/static/chunks/a486667b-8f2171b1f26cbdcb.js" defer=""></script><script src="/me/_next/static/chunks/664-7e38c18dd603f57f.js" defer=""></script><script src="/me/_next/static/chunks/345-14001e255a9bfd38.js" defer=""></script><script src="/me/_next/static/chunks/pages/blog/%5Bid%5D-b2c0b9f35c8b102a.js" defer=""></script><script src="/me/_next/static/51z1C1dEBzUo3Xy84tSwN/_buildManifest.js" defer=""></script><script src="/me/_next/static/51z1C1dEBzUo3Xy84tSwN/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_4ba71e"><nav class="text-s flex justify-center border-b-2 border-gray-100"><div class="flex justify-around max-w-[1200px] w-full"><div class="p-6"><a href="/me/about">About</a></div><div class="p-6"><a href="/me/blog">Blog</a></div><div class="p-6"><a href="/me/other">Other</a></div></div></nav><div class="md:p-16 p-4"><section class="flex flex-col items-center mt-20"><div class="text-6xl mb-10 font-bold text-gray-800">단위테스트 도입 - TDD, 단위 테스트, fixture</div><div class="text-4xl mb-10 text-gray-700"></div><div class="self-end">2017년 03월 29일</div><div class="p-4"><div class="markdown-body"><h2>서론</h2>
<p>올바른 소프트웨어 개발에 있어서 단위 테스트는 반드시 필요하다고 생각합니다. 그러나 의외로 많은 개발자와 개발팀들이 적용의 필요성을 느끼면서도 개발 프로세스에 단위 테스트를 녹여넣는 것에 실패하곤 합니다.</p>
<h2>단위 테스트의 필요성</h2>
<p>때는 2017년 3월쯤, &quot;카링&quot; 프로젝트 초기 api 설계를 할 때입니다. 이 당시에는 개발을 하며 단위 테스트를 수행하지 않았습니다. 그러던 와중 비즈니스 로직 및 모델 단이 복잡해짐에 따라 이 문제점을 해결하기 위해 단위 테스트를 도입하면 어떨까 하는 생각이 들었지만 이전과 같은 한계에 부딫혔습니다.</p>
<h2>단위테스트 vs 데이터베이스</h2>
<p>그 한계란 바로 데이터베이스입니다. 원하는 테스트는 실제 코드 로직을 타면서 언제나 실행해도 같은 결과를 보장, 소위 &quot;멱등성&quot;을 지녀야 한다고 생각했는데, 모델은 데이터를 변조시키기 때문에 그렇지 못합니다. 간단한 예로 CRUD에서 Read 기능 개발을 할 때의 경우는 원하는 결과가 안나오면 수정 후 다시 실행시켜도 문제 없습니다. Read는 데이터를 변조시키지 않기 때문이다. 그러나 나머지의 경우는 아닙니다.</p>
<p>&quot;카링&quot; 기능의 예를 들어보겠습니다. 매장 유저는 기간 내 노출되는 키워드들을 구매하고 연장할 수 있습니다. 만약 기간 연장 기능 개발 시 버그를 발견하였다고 가정하겠습니다. &quot;기존에 있는 &#x27;세차&#x27; 키워드를 1달 연장 시 2달이 연장&quot;되는 버그가 있다고 가정합니다. 버그를 발견하기 위해 코드를 실행 시키는 순간 데이터는 변조됩니다. 만약 버그를 발견하지 못할 시 같은 데이터 state를 확보해야 하고 이 과정에 행이 걸릴 수록 개발-테스트의 이터레이션 속도가 줄어들게 되고 개발자의 피로감도 증가하게 됩니다.</p>
<p>팀 내에서 당시 생각해낸 방법은 local에 테스팅DB와 yml 기반 fixture를 각각 만들어 둔 후</p>
<blockquote>
<p>&quot;실DB에서 스키마만 테스팅 DB로 덤프 → fixture를 테스팅DB에 로드 → ci-phpunit-test 기반 테스트</p>
</blockquote>
<p>의 과정을 거치는 것입니다. 매 테스트마다 mysqldump export, import 를 거치면 느리지 않을까 생각했는데 스키마만 덤프할 경우에는 꽤 빠릅니다.</p>
<p>어떻게 보면 무식한 방법이라고 생각할 수도 있겠지만 단순한 접근이 답일 때도 있습니다. 어쨌든 결과적으로 데이터를 변조하는 테스트가 있다고 해도 계속 실행해도 같은 결과가 나옵니다. 또한 데이터 조회 결과를 test double 등으로 저장했다가 가져쓰는게 아닌 실제 DB단까지 갔다 온 데이터이므로 신뢰성 및 test double 관리 이슈가 사라집니다.</p>
<p>이리하여 걱정없이 테스트를 실행해 볼 수 있게 되므로 개발자가 더욱 대담해지게 되고, 비즈니스 로직 개발에 집중할 수 있게 되었습니다.</p>
<h2>Fixture Editor</h2>
<p>위에서 언급한 yml 기반 fixture는 말 그대로 db에서 dump해와 파일로 따로 관리하는 모델 정보입니다.</p>
<pre><div class="code-style" style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-bash" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>f9 fixture </span><span class="token" style="color:#e6db74">import</span><span> stores </span><span class="token assign-left" style="color:#f8f8f2">id</span><span class="token" style="color:#f8f8f2">=</span><span class="token" style="color:#ae81ff">100</span><span>
</span><span></span><span class="token" style="color:#8292a2"># SELECT * from stores from where id = 100 을 통해 조건에 맞는 row들을 불러와 yml로 저장</span></code></div></pre>
<pre><div class="code-style" style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-yaml" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#8292a2"># fixtures/stores/100.yml</span><span>
</span><span>id</span><span class="token" style="color:#f8f8f2">:</span><span class="token" style="color:#ae81ff">100</span><span>
</span><span>name</span><span class="token" style="color:#f8f8f2">:</span><span class="token" style="color:#a6e22e">&quot;송도카센터&quot;</span><span>
</span><span>categoryId</span><span class="token" style="color:#f8f8f2">:</span><span class="token" style="color:#ae81ff">34</span><span>
</span><span>phoneNumber</span><span class="token" style="color:#f8f8f2">:</span><span class="token" style="color:#a6e22e">&quot;01011112222&quot;</span></code></div></pre>
<p>이슈가 있다면 실DB에 스키마 변경이 있을 경우 해당 fixture들을 다시 로드해야 한다는 점이고, 한 눈에 픽스쳐들을 보기 힘들다는 점입니다.</p>
<p>그리하여 이 fixture 자체를 관리할 수 있는 엑셀과 비슷한 형태의 UI를 form 형태로 간단히 만들어 조회 및 저장, save 시 import를 일괄적으로 수행하여 스키마 싱크가 가능하도록 했습니다.</p>
<h2>한계점 발견</h2>
<p>결국 스키마 싱크가 완전 자동화가 되지 않았고, fixture가 git을 통해 소스로 공유되다보니 permission 이슈, 혹은 충돌나는 이슈도 많았습니다. 정확히는 fixture 값을 수정하는 케이스보다는 스키마를 변경하고 fixture 싱크를 돌린 상황이 많습니다.</p>
<p>또한 relation이 있는 경우 해당 relation을 찾아가 import 해주는 과정이 번거롭습니다. 예를 들어 위 케이스의 경우 id=100인 stores만 import하면 테스트가 정상적으로 작동하지 않습니다. 왜냐하면 id=34인 categories 가 import 되지 않았을 수도 있기 때문입니다. 이런 경우 직접 찾아가며 해당하는 fixture를 모두 import 시켜주어야 한다는 이슈가 있습니다.</p>
<h2>Fixture 자체도 DB로 관리할까?</h2>
<ol>
<li>diff 조회로 스키마 체크 개선</li>
<li>relation scanning 기반 import 개선</li>
</ol>
<p>레이블그룹에서 사용하던 기존의 fixture는 파일 베이스 이기 때문에 파일 자체의 permission, DB의 schema가 변했을 때 관리에 이슈가 있었습니다. 그렇다고 DB 베이스로 하기에는 싱크 과정이 복잡할 것으로 당시에는 판단했습니다.</p>
<p>그 무렵 node.js로 플랫폼 전환을 하게 되면서 기존의 php script에서 node.js 기반으로 새로운 fixture-manager를 만드는 업무를 맡게 되었는데, npm 기반의 라이브러리가 있나 리서치하게 되었는데 이런 라이브러리가 있었습니다.</p>
<p><a href="https://www.npmjs.com/package/dbdiff">dbdiff</a></p>
<p>두 데이터베이스의 스키마를 조회하여 그 차이를 alter table 쿼리로 만들어 리턴하는 라이브러리였습니다.</p>
<pre><div class="code-style" style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-jsx" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#66d9ef">var</span><span> dbdiff </span><span class="token" style="color:#f8f8f2">=</span><span> </span><span class="token" style="color:#e6db74">require</span><span class="token" style="color:#f8f8f2">(</span><span class="token" style="color:#a6e22e">&#x27;dbdiff&#x27;</span><span class="token" style="color:#f8f8f2">)</span><span>
</span> 
<span>dbdiff</span><span class="token" style="color:#f8f8f2">.</span><span class="token method property-access" style="color:#e6db74">describeDatabase</span><span class="token" style="color:#f8f8f2">(</span><span>connString</span><span class="token" style="color:#f8f8f2">)</span><span>
</span><span>  </span><span class="token" style="color:#f8f8f2">.</span><span class="token method property-access" style="color:#e6db74">then</span><span class="token" style="color:#f8f8f2">(</span><span class="token" style="color:#f8f8f2">(</span><span class="token parameter">schema</span><span class="token" style="color:#f8f8f2">)</span><span> </span><span class="token arrow" style="color:#f8f8f2">=&gt;</span><span> </span><span class="token" style="color:#f8f8f2">{</span><span>
</span><span>    </span><span class="token" style="color:#8292a2">// schema is a JSON-serializable object representing the database structure</span><span>
</span><span>  </span><span class="token" style="color:#f8f8f2">}</span><span class="token" style="color:#f8f8f2">)</span><span>
</span> 
<span></span><span class="token" style="color:#66d9ef">var</span><span> diff </span><span class="token" style="color:#f8f8f2">=</span><span> </span><span class="token" style="color:#66d9ef">new</span><span> </span><span class="token" style="color:#e6db74">dbdiff</span><span class="token" style="color:#f8f8f2">.</span><span class="token" style="color:#e6db74">DbDiff</span><span class="token" style="color:#f8f8f2">(</span><span class="token" style="color:#f8f8f2">)</span><span>
</span><span></span><span class="token" style="color:#8292a2">// Compare two databases passing the connection strings</span><span>
</span><span>diff</span><span class="token" style="color:#f8f8f2">.</span><span class="token method property-access" style="color:#e6db74">compare</span><span class="token" style="color:#f8f8f2">(</span><span>conn1</span><span class="token" style="color:#f8f8f2">,</span><span> conn2</span><span class="token" style="color:#f8f8f2">)</span><span>
</span><span>  </span><span class="token" style="color:#f8f8f2">.</span><span class="token method property-access" style="color:#e6db74">then</span><span class="token" style="color:#f8f8f2">(</span><span class="token" style="color:#f8f8f2">(</span><span class="token" style="color:#f8f8f2">)</span><span> </span><span class="token arrow" style="color:#f8f8f2">=&gt;</span><span> </span><span class="token" style="color:#f8f8f2">{</span><span>
</span><span>    </span><span class="token console" style="color:#e6db74">console</span><span class="token" style="color:#f8f8f2">.</span><span class="token method property-access" style="color:#e6db74">log</span><span class="token" style="color:#f8f8f2">(</span><span>diff</span><span class="token" style="color:#f8f8f2">.</span><span class="token method property-access" style="color:#e6db74">commands</span><span class="token" style="color:#f8f8f2">(</span><span class="token" style="color:#a6e22e">&#x27;drop&#x27;</span><span class="token" style="color:#f8f8f2">)</span><span class="token" style="color:#f8f8f2">)</span><span>
</span><span>  </span><span class="token" style="color:#f8f8f2">}</span><span class="token" style="color:#f8f8f2">)</span><span>
</span> 
<span></span><span class="token" style="color:#8292a2">// Compare two schemas</span><span>
</span><span>diff</span><span class="token" style="color:#f8f8f2">.</span><span class="token method property-access" style="color:#e6db74">compareSchemas</span><span class="token" style="color:#f8f8f2">(</span><span>schema1</span><span class="token" style="color:#f8f8f2">,</span><span> schema2</span><span class="token" style="color:#f8f8f2">)</span><span>
</span><span></span><span class="token console" style="color:#e6db74">console</span><span class="token" style="color:#f8f8f2">.</span><span class="token method property-access" style="color:#e6db74">log</span><span class="token" style="color:#f8f8f2">(</span><span>diff</span><span class="token" style="color:#f8f8f2">.</span><span class="token method property-access" style="color:#e6db74">commands</span><span class="token" style="color:#f8f8f2">(</span><span class="token" style="color:#a6e22e">&#x27;drop&#x27;</span><span class="token" style="color:#f8f8f2">)</span><span class="token" style="color:#f8f8f2">)</span></code></div></pre>
<p>기존 방식은 두 데이터베이스를 mysqldump 를 통해 create table 쿼리를 만들어 두 해시값을 비교해 다를 경우 새로 dump하는 방식이었는데, 이 방식보다 훨씬 빠르게 스키마 체크 및 업데이트가 가능하게 되었습니다.</p>
<p><img src="https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/fixture01.png" alt=""/></p>
<p>또한 소스 내에서 공유하는 방식 대신 서버에서 fixture를 관리 할 수 있도록 하기 위하여 서버에 &lt;DB이름&gt;_fixture 라는 새로운 DB를 만들 수 있도록 하여 단위 테스트 실행 시 마다 db-diff로 체크 및 업데이트하도록 했습니다. alter table 기반이므로 새 필드가 추가되면 기본값으로, 삭제될 경우 삭제되기 때문에 그 자체로 이슈는 없습니다. 그 후 로컬에 있는 fixture에는 mysqldump를 통한 완전 복사(캐싱) 후 임포트 하는 식으로 했습니다. depth가 많아진듯 보이지만 실제로는 더 안정적으로 픽스쳐를 관리 할 수 있게 되었습니다.</p>
<p>또한 relation 관련 import 이슈가 단순히 해결되지 않는 이유는 fk를 사용하지 않고 컨벤션에 의존하게 되어 자동화된 스키마 분석이 불가능하기 때문입니다. 그리하여 테이블, 필드명을 모두 가져와 컨벤션을 기반으로 파싱하여 스키마 탐색 결과를 확보했습니다.</p>
<pre><div class="code-style" style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-php" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#66d9ef">class</span><span> </span><span class="token class-name-definition" style="color:#e6db74">Store</span><span> extend Model </span><span class="token" style="color:#f8f8f2">{</span><span>
</span><span>	</span><span class="token" style="color:#66d9ef">var</span><span> </span><span class="token" style="color:#f8f8f2">$id</span><span class="token" style="color:#f8f8f2">;</span><span>
</span><span>	</span><span class="token" style="color:#66d9ef">var</span><span> </span><span class="token" style="color:#f8f8f2">$category_id</span><span class="token" style="color:#f8f8f2">;</span><span>
</span><span>	</span><span class="token" style="color:#66d9ef">var</span><span> </span><span class="token" style="color:#f8f8f2">$name</span><span>
</span><span></span><span class="token" style="color:#f8f8f2">}</span></code></div></pre>
<pre><div class="code-style" style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-php" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#66d9ef">class</span><span> </span><span class="token class-name-definition" style="color:#e6db74">Category</span><span> extend Model </span><span class="token" style="color:#f8f8f2">{</span><span>
</span><span>	</span><span class="token" style="color:#66d9ef">var</span><span> </span><span class="token" style="color:#f8f8f2">$id</span><span class="token" style="color:#f8f8f2">;</span><span>
</span><span>	</span><span class="token" style="color:#66d9ef">var</span><span> </span><span class="token" style="color:#f8f8f2">$name</span><span>
</span><span></span><span class="token" style="color:#f8f8f2">}</span><span>
</span></code></div></pre>
<p>예를 들어 위 케이스의 경우 category_id는 Category 모델과 연결된 fk입니다. 실제로 fk는 걸지 않았지만 index만 걸고 &#x27;테이블단수명_id&#x27;로 끝나는 필드는 fk라는 컨벤션을 유지한 상황입니다.</p>
<p>이러한 정보를 바탕으로 Store에서 한 row를 import 후, 그 row에 category_id의 값으로 Category 테이블에서 추가적으로 데이터를 가져옵니다. 즉 한 특정 모델에서 데이터를 import 해도 many to one 관계에 있는 테이블도 recursive하게 가져올 수 있도록 처리했습니다. 반대로 one to many한 관계에 있는 데이터도 optional하게 가지고 올 수 있도록 처리했습니다.</p></div></div></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"blog":{"id":"3f946c14-5fb3-44be-b5d2-21b3ca99bbf3","title":"단위테스트 도입 - TDD, 단위 테스트, fixture","content":"## 서론\n\n올바른 소프트웨어 개발에 있어서 단위 테스트는 반드시 필요하다고 생각합니다. 그러나 의외로 많은 개발자와 개발팀들이 적용의 필요성을 느끼면서도 개발 프로세스에 단위 테스트를 녹여넣는 것에 실패하곤 합니다.\n\n## 단위 테스트의 필요성\n\n때는 2017년 3월쯤, \"카링\" 프로젝트 초기 api 설계를 할 때입니다. 이 당시에는 개발을 하며 단위 테스트를 수행하지 않았습니다. 그러던 와중 비즈니스 로직 및 모델 단이 복잡해짐에 따라 이 문제점을 해결하기 위해 단위 테스트를 도입하면 어떨까 하는 생각이 들었지만 이전과 같은 한계에 부딫혔습니다. \n\n## 단위테스트 vs 데이터베이스\n\n그 한계란 바로 데이터베이스입니다. 원하는 테스트는 실제 코드 로직을 타면서 언제나 실행해도 같은 결과를 보장, 소위 \"멱등성\"을 지녀야 한다고 생각했는데, 모델은 데이터를 변조시키기 때문에 그렇지 못합니다. 간단한 예로 CRUD에서 Read 기능 개발을 할 때의 경우는 원하는 결과가 안나오면 수정 후 다시 실행시켜도 문제 없습니다. Read는 데이터를 변조시키지 않기 때문이다. 그러나 나머지의 경우는 아닙니다.\n\n\"카링\" 기능의 예를 들어보겠습니다. 매장 유저는 기간 내 노출되는 키워드들을 구매하고 연장할 수 있습니다. 만약 기간 연장 기능 개발 시 버그를 발견하였다고 가정하겠습니다. \"기존에 있는 '세차' 키워드를 1달 연장 시 2달이 연장\"되는 버그가 있다고 가정합니다. 버그를 발견하기 위해 코드를 실행 시키는 순간 데이터는 변조됩니다. 만약 버그를 발견하지 못할 시 같은 데이터 state를 확보해야 하고 이 과정에 행이 걸릴 수록 개발-테스트의 이터레이션 속도가 줄어들게 되고 개발자의 피로감도 증가하게 됩니다.\n\n팀 내에서 당시 생각해낸 방법은 local에 테스팅DB와 yml 기반 fixture를 각각 만들어 둔 후\n\n\u003e \"실DB에서 스키마만 테스팅 DB로 덤프 → fixture를 테스팅DB에 로드 → ci-phpunit-test 기반 테스트\n\n의 과정을 거치는 것입니다. 매 테스트마다 mysqldump export, import 를 거치면 느리지 않을까 생각했는데 스키마만 덤프할 경우에는 꽤 빠릅니다.\n\n어떻게 보면 무식한 방법이라고 생각할 수도 있겠지만 단순한 접근이 답일 때도 있습니다. 어쨌든 결과적으로 데이터를 변조하는 테스트가 있다고 해도 계속 실행해도 같은 결과가 나옵니다. 또한 데이터 조회 결과를 test double 등으로 저장했다가 가져쓰는게 아닌 실제 DB단까지 갔다 온 데이터이므로 신뢰성 및 test double 관리 이슈가 사라집니다.\n\n이리하여 걱정없이 테스트를 실행해 볼 수 있게 되므로 개발자가 더욱 대담해지게 되고, 비즈니스 로직 개발에 집중할 수 있게 되었습니다.\n\n## Fixture Editor\n\n위에서 언급한 yml 기반 fixture는 말 그대로 db에서 dump해와 파일로 따로 관리하는 모델 정보입니다.\n\n```bash\nf9 fixture import stores id=100\n# SELECT * from stores from where id = 100 을 통해 조건에 맞는 row들을 불러와 yml로 저장\n```\n\n```yaml\n# fixtures/stores/100.yml\nid:100\nname:\"송도카센터\"\ncategoryId:34\nphoneNumber:\"01011112222\"\n```\n\n이슈가 있다면 실DB에 스키마 변경이 있을 경우 해당 fixture들을 다시 로드해야 한다는 점이고, 한 눈에 픽스쳐들을 보기 힘들다는 점입니다.\n\n그리하여 이 fixture 자체를 관리할 수 있는 엑셀과 비슷한 형태의 UI를 form 형태로 간단히 만들어 조회 및 저장, save 시 import를 일괄적으로 수행하여 스키마 싱크가 가능하도록 했습니다.\n\n## 한계점 발견\n\n결국 스키마 싱크가 완전 자동화가 되지 않았고, fixture가 git을 통해 소스로 공유되다보니 permission 이슈, 혹은 충돌나는 이슈도 많았습니다. 정확히는 fixture 값을 수정하는 케이스보다는 스키마를 변경하고 fixture 싱크를 돌린 상황이 많습니다.\n\n또한 relation이 있는 경우 해당 relation을 찾아가 import 해주는 과정이 번거롭습니다. 예를 들어 위 케이스의 경우 id=100인 stores만 import하면 테스트가 정상적으로 작동하지 않습니다. 왜냐하면 id=34인 categories 가 import 되지 않았을 수도 있기 때문입니다. 이런 경우 직접 찾아가며 해당하는 fixture를 모두 import 시켜주어야 한다는 이슈가 있습니다.\n\n## Fixture 자체도 DB로 관리할까?\n\n1. diff 조회로 스키마 체크 개선\n2. relation scanning 기반 import 개선\n\n레이블그룹에서 사용하던 기존의 fixture는 파일 베이스 이기 때문에 파일 자체의 permission, DB의 schema가 변했을 때 관리에 이슈가 있었습니다. 그렇다고 DB 베이스로 하기에는 싱크 과정이 복잡할 것으로 당시에는 판단했습니다.\n\n그 무렵 node.js로 플랫폼 전환을 하게 되면서 기존의 php script에서 node.js 기반으로 새로운 fixture-manager를 만드는 업무를 맡게 되었는데, npm 기반의 라이브러리가 있나 리서치하게 되었는데 이런 라이브러리가 있었습니다.\n\n[dbdiff](https://www.npmjs.com/package/dbdiff)\n\n두 데이터베이스의 스키마를 조회하여 그 차이를 alter table 쿼리로 만들어 리턴하는 라이브러리였습니다.\n\n```jsx\nvar dbdiff = require('dbdiff')\n \ndbdiff.describeDatabase(connString)\n  .then((schema) =\u003e {\n    // schema is a JSON-serializable object representing the database structure\n  })\n \nvar diff = new dbdiff.DbDiff()\n// Compare two databases passing the connection strings\ndiff.compare(conn1, conn2)\n  .then(() =\u003e {\n    console.log(diff.commands('drop'))\n  })\n \n// Compare two schemas\ndiff.compareSchemas(schema1, schema2)\nconsole.log(diff.commands('drop'))\n```\n\n기존 방식은 두 데이터베이스를 mysqldump 를 통해 create table 쿼리를 만들어 두 해시값을 비교해 다를 경우 새로 dump하는 방식이었는데, 이 방식보다 훨씬 빠르게 스키마 체크 및 업데이트가 가능하게 되었습니다.\n\n![](https://pihxnuyialxsmkzxlpjj.supabase.co/storage/v1/object/public/bucket01/fixture01.png)\n\n또한 소스 내에서 공유하는 방식 대신 서버에서 fixture를 관리 할 수 있도록 하기 위하여 서버에 \u003cDB이름\u003e_fixture 라는 새로운 DB를 만들 수 있도록 하여 단위 테스트 실행 시 마다 db-diff로 체크 및 업데이트하도록 했습니다. alter table 기반이므로 새 필드가 추가되면 기본값으로, 삭제될 경우 삭제되기 때문에 그 자체로 이슈는 없습니다. 그 후 로컬에 있는 fixture에는 mysqldump를 통한 완전 복사(캐싱) 후 임포트 하는 식으로 했습니다. depth가 많아진듯 보이지만 실제로는 더 안정적으로 픽스쳐를 관리 할 수 있게 되었습니다.\n\n또한 relation 관련 import 이슈가 단순히 해결되지 않는 이유는 fk를 사용하지 않고 컨벤션에 의존하게 되어 자동화된 스키마 분석이 불가능하기 때문입니다. 그리하여 테이블, 필드명을 모두 가져와 컨벤션을 기반으로 파싱하여 스키마 탐색 결과를 확보했습니다.\n\n```php\nclass Store extend Model {\n\tvar $id;\n\tvar $category_id;\n\tvar $name\n}\n```\n\n```php\nclass Category extend Model {\n\tvar $id;\n\tvar $name\n}\n\n```\n\n예를 들어 위 케이스의 경우 category_id는 Category 모델과 연결된 fk입니다. 실제로 fk는 걸지 않았지만 index만 걸고 '테이블단수명_id'로 끝나는 필드는 fk라는 컨벤션을 유지한 상황입니다.\n\n이러한 정보를 바탕으로 Store에서 한 row를 import 후, 그 row에 category_id의 값으로 Category 테이블에서 추가적으로 데이터를 가져옵니다. 즉 한 특정 모델에서 데이터를 import 해도 many to one 관계에 있는 테이블도 recursive하게 가져올 수 있도록 처리했습니다. 반대로 one to many한 관계에 있는 데이터도 optional하게 가지고 올 수 있도록 처리했습니다.","created_at":"2017-03-29T13:00:00+00:00","subtitle":null,"is_show":false}},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"3f946c14-5fb3-44be-b5d2-21b3ca99bbf3"},"buildId":"51z1C1dEBzUo3Xy84tSwN","assetPrefix":"/me","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>